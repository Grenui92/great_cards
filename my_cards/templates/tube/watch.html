{% extends 'base.html' %}
{% block content %}
  <main>
    <div class="video-container">
      <div class="subtitles" id="selectedText">{{ video_path.url }}</div>
      <video class="video-player" controls preload="auto" playsinline>
        <source src="{{ video_path.url }}" type="video/mp4" />
      </video>
      
    </div>

    <div class="hide-translate-subs" id="pops">
        <form class="" method="get" action="{% url 'cards:create_card' %}" target="blank" id="popsContent">
            {% csrf_token %}
            <div class="selected-text" name="from_selection"></div>
            <input type="hidden" id="hiddenSelection" name='hidden_select' value="">
            <button class="submit-button" type="submit">Create Card</button>
        </form>
    </div>

    <script>
      // Получаем ссылки на видео и элемент для субтитров
      const video = document.querySelector('video')
      const subtitlesDisplay = document.querySelector('.subtitles')
      const translateWindow = document.querySelector('.selected-text')
      var pops = document.getElementById("pops");
      var popsContent = document.getElementById("popsContent")
      
      // Путь к файлу субтитров
      const subtitlesFilePath = '{{ video_subs.url }}' // Измените на путь к вашему файлу субтитров
      let prevTime = 0;
      // Загрузка и отображение субтитров
      fetch(subtitlesFilePath)
        .then((response) => response.text())
        .then((data) => {
          const subtitles = parseVTT(data) // Разбор файла VTT
          video.addEventListener('timeupdate', () => {
            const currentTime = video.currentTime
            if (currentTime === prevTime) {
              return
            }
            prevTime = currentTime;
            const currentSubtitle = subtitles.find((subtitle) => {
              return currentTime >= subtitle.start && currentTime <= subtitle.end
            })
            // Если найден соответствующий субтитр, отобразите его текст
            if (currentSubtitle) {
              console.log(currentSubtitle)
              const formattedTime = formatTime(currentTime)
              if (!subtitlesDisplay.textContent.includes(currentSubtitle.text)) {
                const subtitleElement = document.createElement('div')
                subtitleElement.classList.add('subtitle') // Класс для стилей субтитров
                const timecodeElement = document.createElement('span')
                timecodeElement.classList.add('inner-time') // Класс для стилей таймкодов
                timecodeElement.textContent = formattedTime
                const textElement = document.createElement('span')
                textElement.classList.add('inner-text') // Класс для стилей текста субтитров
                textElement.textContent = currentSubtitle.text
                subtitleElement.appendChild(timecodeElement)
                subtitleElement.appendChild(textElement)
                subtitlesDisplay.appendChild(subtitleElement)
                subtitlesDisplay.scrollTop = subtitlesDisplay.scrollHeight
              }
            } else {
              subtitlesDisplay.textContent = '' // Если нет подходящего субтитра, очистите отображение
            }
          })
        })
      
      // Функция для разбора файла субтитров в формате SRT
      function parseVTT(data) {
        const subtitleBlocks = data.split('\n\n')
        return subtitleBlocks
          .map((block) => {
            const lines = block.split('\n').filter((line) => line.trim())
      
            if (lines.length < 2) return null // Пропуск пустых или некорректных блоков
      
            const timecode = lines.shift() // Получаем первую строку временной метки
      
            const timeParts = timecode.split(' --> ')
            if (timeParts.length !== 2) return null // Пропуск некорректных временных меток
            const startPart = timeParts[0]
            const endPart = timeParts[1].split(' ')[0]
      
            const startTime = startPart.split('.')[0].split(':').map(parseFloat)
            const startMillis = startPart.split('.')[1]
      
            const endHHMMSS = endPart.split('.')[0].split(':').map(parseFloat)
            const endMillis = endPart.split('.')[1]
      
            const startSeconds = startTime[0] * 3600 + startTime[1] * 60 + startTime[2] + startMillis / 1000
            const endSeconds = endHHMMSS[0] * 3600 + endHHMMSS[1] * 60 + endHHMMSS[2] + endMillis / 1000
            const text = lines.join('\n')

            return { start: startSeconds, end: endSeconds, text }
          })
          .filter((subtitle) => subtitle !== null) // Фильтрация пустых значений
      }
      
      function formatTime(currentTime) {
        const hours = Math.floor(currentTime / 3600)
        const minutes = Math.floor((currentTime - hours * 3600) / 60)
        const seconds = Math.floor(currentTime - hours * 3600 - minutes * 60)
      
        const formattedHours = String(hours).padStart(2, '0')
        const formattedMinutes = String(minutes).padStart(2, '0')
        const formattedSeconds = String(seconds).padStart(2, '0')
      
        return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`
      }



      document.addEventListener('mouseup', function () {
        var selectedText = window.getSelection().toString().trim();
        if (selectedText !== '') {
    
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                var rect = range.getBoundingClientRect();
    
                pops.style.top = (rect.bottom + window.scrollY) + 'px';
                pops.style.left = (rect.left + window.scrollX) + 'px';
            }
    
            // Отправка данных на сервер
            fetch('http://127.0.0.1:8000/api/v1/chat/translate_sentences/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ selected_text: selectedText })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка при отправке данных');
                }
                return response.json();
            })
            .then(data => {
                console.log(data);
                translateWindow.innerHTML = "English: " + selectedText + "<br><br>";
                translateWindow.innerHTML += "Russian: " + data.message;
                document.getElementById('hiddenSelection').value = translateWindow.innerHTML;
                pops.classList.remove('hide-translate-subs');
                pops.classList.add('look-translate-subs');
            })
            .catch(error => {
                console.error('Ошибка:', error);});

        } else {
            selectedText = ''
            pops.classList.remove('look-translate-subs');
            pops.classList.add('hide-translate-subs');
        }
    });
    </script>
  </main>
{% endblock %}
